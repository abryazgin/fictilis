

[[_TOC_]]


# Что такое `fictilis`?

`fictilis` - это библиотека для построения алгоритмов как структуры, 
как последовательность выполняемых действий и потоков данных между этими шагами. 
С помощью `fictilis` алгоритмы отделяются от непосредственного выполнения.

Действия в `fictilis` отделяются от реализаций действий и декларируют интерфейс.
Согласно этому интерфейсу должны быть написаны рализации действий 
(паттерн Стратегия).


# Зачем это нужно?

* _Алгоритм как выделенная "структура данных" - происходит отделение 
  последовательности выполнения и потоков данных от непосредственного 
  выполнения, как следствие появляется возможность анализа Алгоритма как структуры_:
   * **Оптимизация**. Отбрасываем действия/шаги, которые можем и не выполнять.
   * **Кэширование**. Возврат результатов из кэша без вычислений.
   * **Параллелизация**. Выполнения независимых действий параллельно.
   * **Наглядность**. Алгоритм имеет наглядное описание: он - последовательность 
     определенных действий/шагов и определенных потоков данных. 
     Это позволяет автоматически составлять описание/документацию, определять
     статус выполнения
* _Действие как интерфейс - Действие само по себе не имеет "тела". Для этого должны
  быть написаны Реализации_:
   * **Бизнес-логика**. Алгоритмы ничего не знают про Реализации - они манипулируют 
     только абтрактными Действиями. За счет этого идет отделение бизнес логики
   * **Высокий уровень ООП**. Выделение интерфейсов и реализаций аналогично подходу ООП, 
     но на более высоком уровне - контроль передачи параметров, валидации входных 
     и выходных параметров не скрыто ЯП, а контролируется приложением, как следствие:
      * **Типизация**. Типы могут быть любого уровня, что позволяет ввести типы любого 
        уровня, например исходя из бизнес-сущностей
      * **Валидация**. Валидация тоже может быть абсолютно любой, это позволяет
        ввести, валидация на логическую связанность входных/выходных параметров, 
        причем на уровне Действия, а не на уровне Реализации
   * **Полиморфизм**. Алгоритм может отрабатываться на совершенно разных "движках", 
     то есть иметь абсолютно различные реализации. При это без проблем ложится
     в общую архитектуру
 
# Описание

## Основные понятия

### Действие (Action)

*Действие* - это интерфейс некоторой функции. Определяет входные/выходные параметры и 
некоторые правила. Именно действия используется для описания Алгоритмов.

### Алгоритм (Algorithm)

*Алгоритм* - это описание логики выполнения некоторой последовательности операция.
Состоит из: последовательности Действия и связей потоков данных 
(например: выходное значение `a` некоторого действия `Action1` - 
это входное значение `b` некоторого действия `Action2`). 
Так же Алгоритм - это тоже Действие, т.е. у него тоже есть описание 
входных/выходных параметров и некоторых правил

### Движок (Engine)

*Движок* - способ реализации действий. Сам по себе не несет никакой 
функциональной нагрузки - используется только для "привязывания" и поиску
Реализаций

### Реализация (Implementation)

*Реализация* - это реализация определенного Действия на определенном Движке.
Имеет "тело" - собственно то, что предусмотрено для выполнения Действия 
на Движке.

### Параметр (Parameter)

*Параметр* - это абстракция параметров Действий (и для входа и для выхода). 
Используется для описания кодов и типов входных параметров для Действий/Алгоритмов

### Тип (Type)

*Тип* - это абстракция типа Параметра. Включает в себя валидатор - функцию, 
проверяющую значение на корректность (ожидается выброс исключений 
`TypeError` или `ValueError`)

### Контекст (Context)

*Контекст* - это особый класс (субкласс `dict`), использующийся для хранения особых
для Реализаций данных (например: коннекты к БД). 
В базовом интерпретаторе Алгоритмов в параметры типа `ContextType` 
автоматически подставляется из параметров запуска Алгоритма. 

Валидатор `ContextType` проверяет, что пришедшее значение - инстанс 
класса `Context`)


### Построитель Алгоритма (AlgorithmBuilder)

*Построитель Алгоритма* - это тот, кто построить Алгоритм, используя переданную 
функцию построения. В библиотеке реализован основной построитель 
(`AlgorithmBuilder` - используется "лобовую" регистрацию Алгоритма, т.е. 
прибавляет не много наглядности, но реализует основной функционал и используется
для расширения другими Построителями) и "магический" (`MagicAlgorithmBuilder` - 
перегружает магические методы базовых сущностей, что позволяет сделать построение
много более наглядным)

Используется для того, чтобы построение Алгоритма имело наглядный вид, нежели 
просто набор действий и описаний поток данных.


### Интерпретатор (Interpreter)

*Интерпретатор* - это тот, кто может выполнить Алгоритм. В библиотеке реализован 
базовый Интерпретатор - он лишен логики паралеллизации и прочих плюшек, но 
представляет из себя простой пример Интерпретатора и его можно использовать для
реализации своих Интерпретаторов

## Пример

Приводится простейший пример на примере математических операций. 
"Атомарные" Действия:
* Сумма
* Умножение
* Деление 
* Инверсия числа

Действия описанные в виде Алгоритмов через "атомарные" Действия:
* Вычитание
* Квадрат числа

```python
from fictilis.action import Action, Implementation
from fictilis.algbuilder import MagicAlgorithmBuilder
from fictilis.interpreter import BaseInterpreter
from fictilis.parameter import Parameter
from fictilis import types


def test_simple_usecases():
    # для удобства заблоговременно регистрируем Параметры - их удобно 
    # переиспользовать, нежели описывать прямо в Действиях и Алгоритмах
    res = Parameter(name='res', type_=types.Numeric)
    a = Parameter(name='a', type_=types.Numeric)
    b = Parameter(name='b', type_=types.Numeric)

    # Регистрируем Действия с описанием входных и выходных параметров 
    NegationA = Action('Negation', in_params=[a], out_params=[res])  # инверсия числа
    SumA = Action('Sum', [a, b], [res])  # сумма
    MultiA = Action('Multi', [a, b], [res])  # умножение
    DivisionA = Action('Division', [a, b], [res])  # деление

    # Регистрируем реализации в системе. Способ выполнения у нас - python, поэтому и укажем такой Движок
    engine = 'python'
    Implementation(action=NegationA, engine=engine, function=lambda a: -a)
    Implementation(action=SumA, engine=engine, function=lambda a, b: a + b)
    Implementation(action=MultiA, engine=engine, function=lambda a, b: a * b)
    Implementation(action=DivisionA, engine=engine, function=lambda a, b: a / b)

    # Регистрируем действия в виде Алгоритмов.
    # Обращаем внимание, что никакого выполнения реальных операций ("сложение" и прочее) в этот момент не происходит -
    # это всего лишь интуитивно понятное представление Алгоритма в виде последовательности Действий и потоков данных
    SubtractionA = MagicAlgorithmBuilder.build(
        'SubtractionA', [a, b], [res], builder=lambda a, b: SumA(a=a, b=NegationA(b)))  # Вычитание
    SquareA = MagicAlgorithmBuilder.build(
        'SquareA', [a], [res], builder=lambda a: MultiA(a=a, b=a))  # Квадрат числа

    # А это непосредственно выполнения алгоритма
    assert BaseInterpreter.evaluate(SquareA, params=dict(a=3)) == {'res': 9}
    assert BaseInterpreter.evaluate(SubtractionA, params=dict(a='1', b=2)) == {'res': -1}

```
